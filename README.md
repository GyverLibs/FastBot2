# FastBot2 [beta]
Библиотека Telegram бота для Arduino, ESP8266, ESP32:
- Несколько режимов опроса (long polling, short polling, async short)
- Быстрый парсинг ответов сервера ([в 6 раз быстрее](https://github.com/GyverLibs/GSON?tab=readme-ov-file#%D1%82%D0%B5%D1%81%D1%82%D1%8B) других библиотек на базе ArduinoJSON, в 2-3 раза быстрее первой версии [FastBot](https://github.com/GyverLibs/FastBot))
- Все самые нужные инструменты обёрнуты в удобные классы
- В "ручном режиме" доступен полностью весь [Telegram Bot API](https://core.telegram.org/bots/api)
- Лёгкий вес, эффективное использование оперативной памяти
- Нативная поддержка WiFi ESP8266/ESP32
- Загрузка и скачивание файлов, OTA обновление (ESP8266/ESP32)
- Работает на базе Arduino Client, возможна работа по Ethernet, GSM и так далее
- Виртуальная библиотека, можно добавить связь абсолютно любым способом

> Библиотека в разработке! Руководствуйтесь примером и подсказками IDE

## Установка
Библиотека не в релизе, качайте репозиторий zip архивом (кнопка Code справа вверху) или по [прямой ссылке](https://github.com/GyverLibs/FastBot2/archive/refs/heads/main.zip) на загрузку.

Для работы FastBot2 нужно установить библиотеки:
- [GSON](https://github.com/GyverLibs/GSON)
- [StringUtils](https://github.com/GyverLibs/StringUtils)

## Режим опроса обновлений
### Sync (по умолчанию)
```cpp
bot.setPollMode(fb::Poll::Sync, 4000);
```
#### Обновление
Такой же режим, как в первой версии: библиотека запрашивает обновления и ждёт ответа внутри `tick()`. При плохой связи может "зависать" внутри `tick()` на ощутимое (не дольше таймаута) время. Ставить период меньше 4000 не рекомендуется - сервер Телеграм "накажет" долгим ответом за слишком частый опрос!

#### Отправка сообщений
Отправка сообщений будет быстрой в любом месте программы, т.к. библиотека не ждёт ответа от сервера.

### Async
```cpp
bot.setPollMode(fb::Poll::Async, 4000);
```
#### Обновление
"Асинхронный" режим - библиотека запросит обновления и обработает ответ, когда он придёт. Период опроса - такая же особенность, как в `Sync`.

#### Отправка сообщений
Если отправить сообщение НЕ в обработчике обновления и ВО ВРЕМЯ ожидания ответа с обновлением - библиотека переподключится к серверу, что занимает около 1 секунды и блокирует выполнение программы. Для безопасной отправки из любого места в программе нужно отправлять сообщения, когда библиотека не ждёт ответа - проверить можно по флагу `isPolling()`.

### Long
```cpp
bot.setPollMode(fb::Poll::Long, 10000);
```
#### Обновление
Самый правильный способ опроса - асинхронный long polling. Период можно ставить побольше - от 20 секунд. Библиотека отправляет запрос и получит ответ либо по указанному таймауту, либо по факту поступления новых сообщений в бота. Таймаут переподключения - по умолчанию 300мс. Это самый быстрый и безопасный способ получения обновлений, сообщения доставляются мгновенно.

#### Отправка сообщений
Отправка сообщений в обработчике обновлений - безопасна, сообщения будут отправлены быстро. Если нужно отправить из другого места программы - по флагу `isPolling()` можно узнать, ждёт ли библиотека ответ сервера. Если отправить пока ждёт - будет переподключение ("зависнет" на ~1 секунду).

## Отправка сообщений
### Асинхронность и ID
ID отправленного ботом сообщения можно получить из `lastBotMessage()`. Нужно понимать, что у каждого чата свой счётчик ID сообщений. Библиотека получает ID отправленного сообщения из ответа сервера, поэтому есть несколько важных моментов.

Сообщение может быть отправлено двумя способами:
- **Синхронно** - библиотека ждёт и обрабатывает ответ сервера внутри отправки сообщения, поэтому сразу после вызова `sendMessage` функция `lastBotMessage()` возвращает актуальный ID отправленного сообщения
- **Асинхронно** (по умолчанию) - библиотека не ждёт ответа от сервера и получит его в следующем `tick()`, т.е. `lastBotMessage()` не выдаст достоверный ID сразу после отправки

Поэтому в библиотеке есть несколько условностей и особенностей:
- Принудительно отправить сообщение с ожиданием ответа (синхронно) можно поставив флаг `wait` - `sendMessage(m, true)`
- При отправке нескольких асинхронных сообщений подряд библиотека принудительно будет ждать ответ сервера для каждого предыдущего сообщения, т.е. сделает их синхронными, чтобы избежать переподключения к серверу

```cpp
fb::Message msg("hello", 1234567);
bot.sendMessage(msg);               // асинхронно
Serial.println(lastBotMessage());   // ID может быть некорректным

bot.sendMessage(msg, true);         // синхронно
// библиотека дождётся ответа от предыдущего сообщения, и от нового
Serial.println(lastBotMessage());   // реальный ID
```
