## Отправка
В данной библиотеке, в отличие от многих других, отправка запроса на сервер Telegram идёт не через query string, а в теле запроса типа application/json. Это означает, что отправляемый текст не должен быть urlencoded и не имеет прочих ограничений, а может отправляться в неизменном виде - это сильно экономит время и ресурс контроллера. Также это избавляет от проблем с отправкой сообщений в стилях HTML и Markdown.

### ID чата и тип Value
В большинстве команд отправки нужен id чата - уникальный номер чата или группы в Telegram. Это число выходит за рамки типа данных `long`, поэтому в библиотеке используется тип данных `Value` ([документация](https://github.com/GyverLibs/StringUtils?tab=readme-ov-file#suvalue)). Он принимает как числа любого типа, так и строки. Таким образом id чата при работе с FastBot2 можно хранить как в строках в любом виде, так и в целочисленной переменной типа `int64_t` (`long long`) - очень удобно для взаимодействия и хренения в энергонезависимой памяти (EEPROM/Flash). Например:
```cpp
su::Value val;
val = "1234567898765";
val = 1234567898765;
```

При разборе обновлений id чата является типом `Text`, который в свою очередь может конвертироваться в `int64_t`:
```cpp
int64_t chat_id;

void update(fb::Update& u) {
    u.message().from().id() == 12345678ll;  // сравнение
    chat_id = u.message().from().id();      // сохранение в переменную
}
```
Поэтому для отправки можно использовать id в любом виде.

### Отправка сообщений
FastBot2 удобно оборачивает почти весь API по отправке сообщения в класс `fb::Message`. Типичный сценарий использования:
- Создать `fb::Message`
- Заполнить обязательные параметры - `text` и `chatID`
- По желанию заполнить другие параметры
- Отправить в `sendMessage`

```cpp
fb::Message msg;
msg.text = "some text";
msg.chatID = 123456677889;  // или в виде строки
bot.sendMessage(msg);
```

Возможна укороченная запись, `Message` имеет конструктор с минимальными обязательными параметрами:
```cpp
bot.sendMessage(fb::Message("hello!", "12312424353"));
```

### Асинхронность и ID сообщения
ID отправленного ботом сообщения можно получить из `lastBotMessage()`. Нужно понимать, что у каждого чата свой счётчик ID сообщений. Библиотека получает ID отправленного сообщения из ответа сервера, поэтому есть несколько важных моментов.

Сообщение может быть отправлено двумя способами:
- **Синхронно** - библиотека ждёт и обрабатывает ответ сервера внутри отправки сообщения, поэтому сразу после вызова `sendMessage` функция `lastBotMessage()` возвращает актуальный ID отправленного сообщения
- **Асинхронно** (по умолчанию) - библиотека не ждёт ответа от сервера и получит его в следующем `tick()`, т.е. `lastBotMessage()` *не выдаст* достоверный ID сразу после отправки

Поэтому в библиотеке есть несколько условностей и особенностей:
- Принудительно отправить сообщение с ожиданием ответа (синхронно) можно поставив флаг `wait` - `sendMessage(m, true)`
- При отправке нескольких асинхронных сообщений подряд библиотека принудительно будет ждать ответ сервера для каждого предыдущего сообщения, т.е. сделает их синхронными, чтобы избежать переподключения к серверу

```cpp
fb::Message msg("hello", 1234567);
bot.sendMessage(msg);               // асинхронно
Serial.println(lastBotMessage());   // ID может быть некорректным

bot.sendMessage(msg, true);         // синхронно
// библиотека дождётся ответа от предыдущего сообщения перед отправкой нового
Serial.println(lastBotMessage());   // реальный ID
```

### Редактирование сообщений
Для редактирования текста сообщений используется следующая конструкция:
```cpp
fb::TextEdit et;
et.text = "edited text";
et.chatID = 123423234;
et.messageID = 234;
bot.editText(et);
```

Вот так например бот будет удалять сообщения юзера и вместо этого менять текст своего последнего сообщения на текст сообщения юзера:
```cpp
// удалить сообщение юзера
bot.deleteMessage(u.message().chat().id(), u.message().id());

// редактировать
if (bot.lastBotMessage()) {
    fb::TextEdit et;
    et.text = u.message().text().toString();
    et.chatID = u.message().chat().id();
    et.messageID = bot.lastBotMessage();
    bot.editText(et);
} else {
    // отправить сообщение, если бот не знает id своего последнего сообщения
    bot.sendMessage(fb::Message(u.message().text(), u.message().chat().id()));
}
```

Отдельно можно редактировать меню сообщения через `MenuEdit`.

### Отправка нескольким ID
Если ID хранятся в текстовом виде в виде CSV списка, то можно использовать парсер `Text`:
```cpp
fb::Message msg;
msg.text = "hello!";

su::TextParser ids("546343285;1234853;8796453678;38347567", ';');
while (ids.parse()) {
    msg.chatID = ids;
    bot.sendMessage(msg);
}
```

Если id - это массив `int64_t` - то всё проще:
```cpp
int64_t ids[..];    // массив id
int ids_len;        // фактическая длина

// ...
fb::Message msg;
msg.text = "hello!";

for (int i = 0; i < ids_len; i++) {
    msg.chatID = ids[i];
    bot.sendMessage(msg);
}
```

### Отправка файлов
Файл можно отправить 4-мя способами:
- Из файла файловой системы (esp8266/esp32)
- Из байтового буфера (например кадр с камеры или текст)
- По ссылке из Интернета
- Существующий файл в Телеграм по id файла

Для отправки файла нужно создать объект класса `fb::File`, который наследует возможности класса `Message` - таким образом к файлу можно добавить подпись (`caption`), меню и прочее.
```cpp
// отправка файла из файла
File file = LittleFS.open("/image.jpg", "r");
fb::File f("file.txt", fb::File::Type::photo, file);
f.chatID = 123123123213;
f.caption = "подпись к файлу";
bot.sendFile(f);

// отправка файла из буфера
char str[] = "hello text";
fb::File f("file.txt", fb::File::Type::document, (uint8_t*)str, strlen(str));   // указать длину данных!
f.chatID = 13231231234;
bot.sendFile(f);

// отправка файла из Интернет
fb::File f("file.txt", fb::File::Type::document, "https://compote.slate.com/images/697b023b-64a5-49a0-8059-27b963453fb1.gif");
f.chatID = 132453234;
bot.sendFile(f);
```

### Редактирование файлов
Для редактирования файла достаточно создать объект класса `FileEdit`, указать файл таким же образом как при отправке, указать необходимые параметры и отправить редакцию:
```cpp
char str[] = "hello text v2";
fb::FileEdit f("file.txt", fb::File::Type::document, (uint8_t*)str, strlen(str));
f.messageID = 123123123;    // id сообщения с прошлым файлом
f.chatID = 3231321321;
bot.editFile(f);
```

Для изменения подписи или меню нужно использовать `CaptionEdit` и `MenuEdit` соответственно.

## Отправка вручную
Библиотека поддерживает самостоятельную сборку пакетов для отправки на сервер согласно API Telegram. Для сборки используется линейный сборщик json строк `gson::string` - вот [документация](https://github.com/GyverLibs/GSON?tab=readme-ov-file#gsonstring). Создание и отправка пакета выглядит так:
- Начать пакет с указанием [команды](https://core.telegram.org/bots/api#available-methods)
- Собрать пакет, указав нужные данные
- Отправить пакет

Отправка сообщения в чат:
```cpp
// Все команды API Telegram доступны в fb::cmd
fb::Packet p = bot.beginPacket(fb::cmd::sendMessage);

// все ключи объектов API Telegram доступны в fb::api
p.addString(fb::api::text, "message text");
p.addInt(fb::api::chat_id, 12312341231);
bot.sendPacket(p);
```

Установка команд бота, способ 1 (с элементом json строки):
```cpp
fb::Packet p = bot.beginPacket(fb::cmd::setMyCommands);
p.beginArr(fb::api::commands);
p.addText(R"(
    {"command":"help","description":"Помощь по командам"},
    {"command":"info","description":"Информация о настройках"}
)");
p.endArr();
bot.sendPacket(p);
```

Установка команд бота, способ 2 (полностью нативная сборка):
```cpp
fb::Packet p = bot.beginPacket(fb::cmd::setMyCommands);
p.beginArr(fb::api::commands);
p.beginObj().addString(fb::api::command, "help").addString(fb::api::description, "Помощь по командам").endObj();
p.beginObj().addString(fb::api::command, "info").addString(fb::api::description, "Информация о настройках").endObj();
p.endArr();
bot.sendPacket(p);
```